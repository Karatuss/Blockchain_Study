# 2 스마트 컨트랙트
스마트 컨트랙트란 객체지향 프로그램에서 클래스와 유사한 독립적인 코드로 탈중앙화 문제들을 풀기 위한 컨트랙트 규칙들을 구현한다.  
## 2.1 스마트 컨트랙트 개념
스마트  먼트랙트는 암호 화폐 이외의 디지털 자산을 위한 트랜잭션을 지원할 수 있는 프로그래밍을 가능하게 해준다.
우리는 이더리움의 스마트 컨트랙트 정의를 사용  


이더리움 스마트 컨트랙트 장점
* 가장 많이 사용하는 범용적인 퍼블릭 블록체인
* 수많은 다른 사업 블록체인을 위한 표준 구현체로 활약

스마트 컨트랙트는 샌드박스 환경에 배포  

블록체인 네트워크의 참여자들을 식별하는 데 사용하는 160비트의 어카운트 주소를 사용해 식별


![화면 캡처 2023-07-18 032100](https://github.com/TwoPair/Blockchain_Study/assets/101495241/702f8703-0a77-4488-928e-9d046e64150b)


### 비트코인 트랜잭션 vs 스마트 컨트랙트 트랜잭션

비트코인 트랜잭션 : 모든 트랜잭션은 가치(Tx) 즉 암호 화폐의 전송을 하기 위함  
스마트 컨트랙트 트랜잭션 : 트랜잭션은 스마트 컨트랙트가 구현한 기능을 임베드한다 (어떠한 애플리케이션 로직도 지원 가능)

![image](https://github.com/TwoPair/Blockchain_Study/assets/101495241/06372527-210f-43c7-ae9e-c8fafa05e896)

### 스마트 컨트랙트는 무엇을 하나?
* 각 애플리케이션의 특수한 조건에 맞는 **확인과 검증**을 할 수 있는 비즈니스 로직 레이어를 표현  
* 블록체인에서 작동하기 위한 **규칙의 명세(세부)를 설정**  
* 탈중앙화 네트워크에서 자산의 전송을 위한 정책을 구현하기 쉽도록 한다.  
* 메시지나 **다른 함수의 호출에 의해 실행되는 함수를 내장**하는데, 개인 어카운트나 다른 스마트 컨트랙트 어카운트가 이런 호출을 하게 된다. 이 메시지는 **블록체인의 분산 장부에 트랜잭션 일부로 기록**되는데, 여기에는 입력 파라미터, 송신자의 주소, 타임스탬프 등과 같은 추가적인 메타 데이터를 포함한다.  
* 탈중앙화 블록체인 기반 에플리케이션을 위한 소프트웨어 기반 중개자로 기능한다.  
* 스마트 컨트랙트 기능의 구체적인 설정을 통해 블록체인에게 프로그래밍 가능성과 지능성을 제공한다.  


## 2.2 스마트 컨트랙트의 설계
스마트 컨트랙트로 해결해야 할 문제 설정에서부터 코드의 배포에 이르기까지 전 과정을 살펴볼 수 있는 간단한 예제를 통해 스마트 컨트랙트 설계를 탐구하자.  

다양한 시스템의 카운터 예들

![그림1](https://github.com/TwoPair/Blockchain_Study/assets/101495241/53ca1fc7-d5cb-4418-b5b1-673f915d1f23)

카운터는 단순하지만, 스마트 컨트랙트 개발의 다양한 유스 케이스를 보여줄 수 있는 좋은 예이다.  

#### 설계 원칙 1 : 테스트 체인에서 스마트 컨트랙트를 코딩, 개발, 배포하기 전에 우선 설계부터 한다. 스마트 컨트랙트는 변조 불가능하다.

설계 과정의 목표  
* 데이터
* 데이터를 처리할 함수
* 처리를 위한 규칙

#### 설계 원칙 2 : 시스템 사용자와 유스 케이스를 정의한다. 사용자란 행위와 입력값을 발생시키고, 설계하고 있는 해당 시스템으로부터 그 출력값을 받는 주체다.

### 카운터를 위한 유스 케이스 다이어그램

UML 유스 케이스 다이어그램은 해결해야 할 문제와 스마트 컨트랙트를, 정확히는 그것의 함수들이 어떻게 사용해야 할지에 대해 숙고할 수 있도록 해준다. (부록 A 참조)

![그림2](https://github.com/TwoPair/Blockchain_Study/assets/101495241/348df51d-7b8d-418b-a29f-c93e1adb4f3a)

위 그림에서 액터는 하나뿐인데, 카운터를 사용할 탈중앙화 애플리케이션을 막대 그림으로 표현한다.  

* initialize() - 값에 대한 초기화
* increment() - 주어진 값만큼 증가
* decrement() - 주어진 값만큼 감소
* get() - 카운터값을 가져오기

한가지 주의점은 이 단계에서 만든 설계 내용이 해결해야 하는 문제에는 종속적이지만, 특정한 코딩 또는 시스템에는 종속적이지 않다는 점이다.

### 데이터 애셋, 피어 참여자, 역할, 규칙, 그리고 트랜잭션

#### 설계 원칙 3 : 데이터 애셋, 피어 참여자, 그들의 역할, 강제할 규칙, 설계하고 있는 시스템에 기록해야 할 트랜잭션을 정의한다.

탈중앙화 카운터 문제에서 설계 원칙 3을 적용하면 다음과 같은 아이템을 설정할 수 있다.  
* 추적해야 할 데이터 애셋 - 카운터값
* 피어 참여자 - 카운터값을 업데이트할 애플리케이션
* 참여자의 역할 - 카운터값을 업데이트하고 그 값에 액세스하는 것
* 데이터와 함수에 검증, 검사해야 할 규칙 - 이 유스 케이스에는 없음
* 디지털 장부에 기록해야 하는 트랜잭션 - initialize(), increment(), decrement()

*카운터값을 바꾸는 함수나 트랜잭션만을 기록하면 된다는 점을 주목! get() 함수는 카운터의 내용을 보기만 할 뿐이므로 기록할 필요가 없다(이를 읽기 전용 함수라 한다)*

### 클래스 다이어그램에서 컨트랙트 다이어그램으로

* 카운터 문제 해결 설계를 위해 UML 클래스 다이어그램을 설정한다.
* 클래스 다이어그램은 솔루션의 여러 가지 구조적 요소들을 정의한다.


전통적인 객체지향 프로그래밍의 전형적인 UML 클래스 다이어그램은 다음의 세 가지 요소를 포함한다.
* 클래스의 이름
* 데이터 정의
* 함수 정의

![그림 3](https://github.com/TwoPair/Blockchain_Study/assets/101495241/740b8831-8a0f-4f02-9a20-e0384129a0ca)

#### 설계 원칙 4 : 컨트랙트 이름, 데이터 애셋, 함수, 함수의 실행과 데이터 접근을 위한 규칙을 정의하는 컨트랙트 다이어그램을 작성한다.

단순한 카운터 유스 케이스에서는 조건이나 규칙을 사용하지 않는다.  

다음 그림은 카운터를 위한 컨트랙트 다이어그램이다.

![rmfla 4](https://github.com/TwoPair/Blockchain_Study/assets/101495241/6f76b29a-15ac-4a3f-948d-bf64e16af8ef)

위 그림에서 다이어그램은 컨트랙트 이름이 Counter라는 것을 보여주고, value라는 정수 데이터가 있다.  
constructor() 함수는 스마트 컨트랙트가 블록체인 인프라에서 작동하는 VM 샌드박스에 처음 배포되었을 때 한 번만 작동한다.  
get() 함수는 카운터의 현재 값을 리턴하는 유틸리티 함수이다.  

## 2.3 스카트 컨트랙트 코드 작성

우리는 스마트 컨트랙트 코딩을 하기 위해서 솔리디티 언어를 사용할 것이다.  
스마트 컨트랙트 코드는 어카운트 주소, 규칙 사양, 트랜잭션 되돌림(reversal)과 같은 블록체인에 특화된 특정 기능이 언어에 내장되어 있어야 한다.  
또한, 스마트 컨트랙트 코드는 여러 블록체인 노드에서 실행될 때 일관성을 유지하기 위해 **제한된** 샌드박스 환경에서 실행된다.

### 솔리디티 언어

솔리디티는 정적 타입 언어이고, 상속, 라이브러리, 사용자 저장 타입 등을 지원한다.  
시뮬레이트된 블록체인 위에 스마트 컨트랙트 코드를 작성, 수정, 컴파일하고, 이를 배포하고 테스트하기 위해 리믹스 통합 개발환경을 사용할 것이다.

### 카운트를 위한 스마트 컨트랙트 코드
```
pragma solidity ^0.6.0;

contract Counter {
    uint value;
    function initialize (uint x) public {
        value = x;
    }

    function get () view public returns (uint) {
        return value;
    }

    function increment (uint n) public {
        value = value + n;
        // return (optional)
    }

    function decrement (uint n) public {
        value = value - n;
    }
}
```

* pragma : 이 코드를 작성하는 데 사용한 언어의 버전 (solidity언어 0.6.0 버전)
## 2.4 스마트 컨트랙트 코드를 배포하고 테스트하기

이 장은 코드를 작성하는 개발 환경에 대한 설명으로 직접 실행해 보길 바란다

### 핵심 사항

스마트 컨트랙트 코드를 블록체인에 배포하였을 때 블록체인에 정의된 아이덴티티를 가진 누구나 이것에 접근할 수 있다.  

블록체인은 변조 불가능한 분산 장부를 사용함으로써, 모든 참여자는 해당 스마트 컨트랙트상에 일어난 모든 트랜잭션 리스트와 동일한 카피를 가지게 된다.  

또한 변조 불가능한 장부는 각 트랜잭션을 누가, 언제, 무슨 내용으로 실행했는지에 대한 출처 추적이 가능하다.  

이러한 블록체인의 변조 불가능한 분산 장부는 서로 알지 못하는 탈중앙화 참여 노드 간에 신뢰를 구축하고, 혁신적인 Dapp을 위한 새로운 차원의 기회를 제공해 준다.
